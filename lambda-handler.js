// TODO this could be split out into different services on different APIs
// additional API gateway for reading from Github
// additional API for sending messages via Slack
const crypto = require('crypto')
const https = require('https')
const url = require('url')

// we will use this as temporary storage whilst the Lambda is active
let state = {}

// required config for accessing the SSM
const AWS = require('aws-sdk')
AWS.config.update({
  region: 'eu-west-1'
})

const parameterStore = new AWS.SSM()
// List of the names of the parameters defined in the Parameter Store
const REQUIRED_PARAMS = [
  'your-github-rest-api-token-param-name',
  'your-github-webhook-secret-param-name',
  'your-github-dev-reviewer-ids-param-name',
  'your-jira-api-user-param-name',
  'your-jira-api-token-param-name',
  'your-slack-api-token-param-name'
]

// key is Github user id and value is the users slack handle
const GITHUB_ID_TO_SLACK_USER_NAME_MAPPING = {
  123456: 'kro',
}

// Ids of all 'Dev' reviewers (need to be able to distinguish between UI reviewers and Dev reviewers)
const DEV_TEAM = [
  123456,
]

// https://{your organisation}.atlassian.net/secure/admin/workflows/ViewWorkflowSteps.jspa?workflowMode=draft&workflowName={your workflow name}
const JIRA_READY_FOR_QA_TRANSITION_ID = '91'
const REST_API_BASE_PATH = '/rest/api/latest'

// helper method to generate a http response payload
const generateResp = (message, code = 200) => {
  return {
    statusCode: code,
    body: JSON.stringify({ message })
  }
}

// helper method to query the Parameter Store and retrieve the required parameters
const getParams = async(params) => {
  return parameterStore.getParameters({
    Names: params,
    WithDecryption: true,
  }).promise()
}

// we need to derive a hash generated by combining the request payload and the Webhook secret
const generateHashFromPayload = async(payload) => {
  return crypto.createHmac('sha1', state.GithubWebhookSecret)
  .update(payload.body)
  .digest('hex')
}

// parse the PR reviews returned from querying the Github REST API
// 1. get a list of Dev reviewers excluding the PR author
// 2. filter to the latest review from each user
// 3. generate a count of the Approved filtered Dev reviews
const extractDevReviewApprovalCount = (reviews) => {
  const devReviewerIds = state.GithubDevReviewerIds.split(',')
  // Grab all Dev reviews excluding the PR Author
  const devReviews = reviews.filter((r) => {
    const reviewerId = r.user.id.toString()
    return reviewerId !== state.pullRequest.userId && devReviewerIds.includes(reviewerId)
  })
  const newestReviewsByUser = []
  // Generate an Array of the latest Review Objects for each user (excluding those which are comments)
  devReviews.forEach((review) => {
    // we only care about those which are not comments
    if (review.state.toUpperCase() !== 'COMMENTED') return
    const existingIdx = newestReviewsByUser.findIndex((r) => r.user.id === review.user.id)
    // we haven't already stored a review Object in newestReviewsByUser for this user
    if (existingIdx === -1) {
      newestReviewsByUser.push(review)
    } else if (Date.parse(review.submitted_at) > Date.parse(reviews[existingIdx].submitted_at)) {
      // replace the existing review Object in newestReviewsByUser for this user as the current 'review' is newer
      newestReviewsByUser[existingIdx] = review
    }
  })
  return newestReviewsByUser.filter(isApprovingReview).length
}

// generate our REST API token for Jira requests
const generateBasicAuthToken = () => {
  return 'Basic ' + Buffer.from(state.JiraApiUserName + ':' + state.JiraApiToken).toString('base64')
}

// query the Github REST API in order to retrieve all reviews associated with the PR
// use the response to generate a count of relavant approvals
const fetchDevApprovalCount = async(pullRequestUrl) => {
  const q = url.parse(pullRequestUrl, true)
  const options = {
    host: q.host,
    path: q.pathname + '/reviews?per_page=100',
    method: 'GET',
    headers: {
      'Authorization': 'token ' + state.GithubRestAPIToken,
      'User-Agent': 'https://github.com/YourOrganisation',
    },
  }

  return new Promise(function(resolve) {
    https.get(options, (resp) => {
      let data = ''
      resp.on('data', (chunk) => {
        data += chunk
      })
      resp.on('end', () => {
        const devReviewCount = extractDevReviewApprovalCount(JSON.parse(data))
        resolve(devReviewCount)
      })
    }).on("error", (err) => {
      console.log("Error: " + err.message)
      resolve(0)
    })
  })
}
    
// a helper method to generate our POST request
const generatePostRequest = ({ options, postData }) => {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      res.setEncoding('utf8')
      let status
      let message = null
      let data = ''
      res.on('data', chunk => data += chunk)
      const { body } = data
      res.on('end', () => {
        if (res.statusCode == 204 || res.statusCode === 200) {
          status = 'success'
        } else {
          status = 'error'
          const parsedData = JSON.parse(data)
          message = parsedData.errorMessages ? parsedData.errorMessages.join(', ') : parsedData.message
        }
        resolve({ status, message })
      })
    }).on('error', (err) => {
      reject({ status: 'error', message: err.message || JSON.stringify(err)})
    })
    
    req.write(postData)
    req.end()
  })
}

// POST against the Jira REST API to update the issue transition in the workflow
// user comes from Github payload - review.user
// issueID: Jira ticket id - transitionId: Jira Workflow transition id
const transitionJiraIssue = (issueId, transitionId) => {
  const authToken = generateBasicAuthToken()
  var options = {
    'method': 'POST',
    'hostname': 'your-org.atlassian.net',
    'path': REST_API_BASE_PATH + '/issue/' + issueId + '/transitions?',
    'headers': {
      'Content-Type': 'application/json',
      'Authorization': authToken
    },
    'maxRedirects': 20
  }

  return generatePostRequest({
    options,
    postData: JSON.stringify({ transition: { id: transitionId } })
  })
}

// generate the Slack message payload
const generateSlackPayload = (message) => {
  const { title, link, userId } = state.pullRequest
  return {
    "text": "Transition Info for " + state.ticketId,
    "blocks": [{
        "type": "section",
        "text": {
          "type": "mrkdwn",
          "text": "<@" + GITHUB_ID_TO_SLACK_USER_NAME_MAPPING[userId] + "> \n *_" +
            title + "_* \n" + message
        }
      },
      {
        "type": "divider"
      },
      {
        "type": "context",
        "elements": [{
            "type": "mrkdwn",
            "text": "<https://your-org.atlassian.net/browse/" + state.ticketId  + "|Jira Ticket>"
          },
          {
            "type": "mrkdwn",
            "text": " *|* "
          },
          {
            "type": "mrkdwn",
            "text": "<" + link + "|Github PR>"
          }
        ]
      }
    ]
  }
}

// helper method to send the Slack notification - will either be success message with PR name and Jira/Github links
// or an error notification outlining why the transition didn't happen
const sendSlackMessage = (jiraResponse) => {
  let message
  if (jiraResponse.status === 'success') {
    message = ":rocket: has been be transitioned to *Ready for QA* :white_check_mark:"
  } else {
    message = "could *NOT* be transitioned to *Ready for QA* :x: \n\n`" + jiraResponse.message + "`"
  }
  const payload = generateSlackPayload(message)
  const options = {
    hostname: 'hooks.slack.com',
    path: '/services/your/slack/hook-url',
    method: 'POST',
    headers: {
      'Authorization': 'Bearer ' + state.SlackApiToken,
      'Content-Type': 'application/json',
    },
  }
  return generatePostRequest({
    options,
    postData: JSON.stringify(payload)
  })
}

// return if this review is an approval
const isApprovingReview = (review) => review.state.toUpperCase() === "APPROVED"

// parse the review body and extract the Jira ticked id
// Regex why do you hate me so???
const getJiraTicketId = (pullRequest) => {
  const { title, body } = pullRequest.pull_request
  let ticketId = null
  const rgx = /(atlassian.net\/browse\/[^\s]+)/g
  const regexMatch = body.match(rgx) || title.match(rgx) // >> [ 'atlassian.net/browse/AT-3798' ]
  if (Array.isArray(regexMatch)) {
    ticketId = regexMatch[0].split('/').pop() // >> AT-3798
  }
  return ticketId
}

// Lambda entry point
exports.handler = async(payload) => {
  const {
    body,
    headers,
  } = payload

  // Pull the required values from the Parameter Store and store them in State
  const retrievedParams = await getParams(REQUIRED_PARAMS)
  // validate that we've retrieved all the items we need from the Parameter Store
  if (retrievedParams.Parameters && !retrievedParams.InvalidParameters.length) {
    // Push these into State for later use
    REQUIRED_PARAMS.forEach((param) => {
      state[param] = retrievedParams.Parameters.find((p) => p.Name === param).Value
    })
    
    const derivedHash = await generateHashFromPayload(payload)
    // Github send X-Hub-Signature in header whose value is generated by hashing the 'body' with the secret we defined in the webhook config
    // We need to generate a Hash of the 'body' using 'sha1 hex' which we can use to validate by comparing against the X-Hub-Signature header
    // grab the X-Hub-Signature header from the payload
    const requestSigHeader = headers['X-Hub-Signature']
    let hasValidHeader = false
    // validate the header matches the payload
    hasValidHeader = requestSigHeader && requestSigHeader.split('sha1=').pop() === derivedHash
    // only continue if we have validated the payload
    if (hasValidHeader) {
      // store the parsed payload body 
      const reviewBody = JSON.parse(body)
      const { pull_request, review } = reviewBody
      // store the pull request in State for later use
      state.pullRequest = { title: pull_request.title, link: pull_request.html_url, userId: pull_request.user.id }
      // this is an approving review
      const isApproval = isApprovingReview(review)
      // this PR reviewer is a member of the Dev team
      const isDevReviewer = DEV_TEAM.includes(state.pullRequest.userId)
      // if this review approves the PR and was created by a Dev team member
      if (isApproval && isDevReviewer) {
        // fetch additional reviews for this PR and parse the response to derive a total count of approving reviews by Devs
        const devApprovalCount = await fetchDevApprovalCount(pull_request.url)
        // grab the ticket id from the review body (Jira ticket url is part of our PR template)
        const ticketId = getJiraTicketId(reviewBody)
        // store this in State for later use
        state.ticketId = ticketId
        // Transition Jira ticket to Ready for QA
        if (ticketId && devApprovalCount >= 2) {
          const resp = await transitionJiraIssue(ticketId, JIRA_READY_FOR_QA_TRANSITION_ID)
          // notify the user that we've auto transitioned this ticket
          await sendSlackMessage(resp)
        }
        // respond with the approval count in the payload
        return generateResp('We have ' + devApprovalCount + ' approvals for ' + ticketId, 200)
      } else {
        // respond with 'no change'
        return generateResp('No change', 200)
      }
    }
    else {
      // There's something dodgy about this request so quote the Dude!
      return generateResp('Obviously you\'re not a golfer', 422)
    }
  }
  else {
    // for the purpose of debugging
    return generateResp('Failed to retrieve required parameters', 422)
  }
}